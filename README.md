# Лабораторная работа 4: Реализация алгоритма «Next Fit» (следующего подходящего) выделения участков памяти по запросу

## 1. Задание
Необходимо согласно заданию провести исследование, создать новый компонент для ARM архитектуры и платформы Eco OS с bare-metal реализацией на эмуляторе qemu. Исследовательская часть заключается в изучении аппаратной составляющей
или в поиске описания алгоритма, необходимых для реализации согласно выбранной задачи.

Задание: Реализация алгоритма «Next Fit» (следующего подходящего) выделения участков памяти
по запросу.

## 2. Реализуемый алгоритм

Алгоритм Next Fit является модификацией стратегии First Fit. В отличие от First Fit, поиск подходящего свободного блока начинается не с начала памяти, а с позиции, следующей за предыдущим успешным выделением.

При запросе N байт алгоритм:
* начинает поиск с текущей позиции курсора
* последовательно просматривает блоки памяти
* при достижении конца памяти продолжает поиск с начала (циклический обход)
* выбирает первый свободный блок, размер которого достаточен для размещения запроса

Таким образом, алгоритм Next Fit сохраняет состояние поиска между вызовами, что отличает его от стратегий, всегда начинающих поиск с начала памяти.

### Преимущества алгоритма Next Fit:
* потенциальное снижение времени поиска по сравнению с Best Fit за счёт отсутствия полного обхода списка блоков
* более равномерное распределение нагрузки по памяти
* хорошая производительность при большом количестве блоков

### Недостатки:
* возможна более высокая фрагментация памяти по сравнению с Best Fit
* качество размещения блоков зависит от текущего положения курсора

## 3. Реализация

### 3.1 Структура данных

Для управления динамической памятью используется представление кучи в виде последовательности взаимосвязанных блоков памяти. Каждый блок описывается структурой `MemoryBlock`, которая содержит как служебную информацию, так и сведения о состоянии блока. Метаданные располагаются непосредственно в управляемой области памяти перед пользовательскими данными.

```c
typedef struct MemoryBlock {
    struct MemoryBlock* next;  /* Указатель на следующий блок */
    struct MemoryBlock* prev;  /* Указатель на предыдущий блок */
    uint32_t payload;          /* Размер полезной области */
    uint8_t  isFree;           /* Флаг: свободен ли блок */
} MemoryBlock;
```

Структуры `MemoryBlock` образуют двусвязный список, который описывает текущее разбиение кучи на занятые и свободные блоки. Использование двусвязного списка упрощает навигацию по памяти и позволяет эффективно выполнять операции объединения смежных свободных блоков при освобождении памяти.

### 3.2 Инициализация

При инициализации менеджера памяти весь доступный участок памяти размечается как один большой свободный блок.
Создаётся первый блок памяти по начальному адресу кучи (m_pHeapStart), в который записывается размер доступной памяти с учетом размера служебной информации.

Курсор алгоритма Next Fit инициализируется указателем на первый блок памяти.

### 3.3 Выделение памяти

При вызове функции `Alloc` выполняются следующие шаги:

#### 1. Выравнивание запроса
Размер запрашиваемой памяти выравнивается по размеру машинного слова (`sizeof(voidptr_t)`), что обеспечивает корректную работу на различных архитектурах.

#### 2. Поиск блока (Next Fit)
Поиск свободного блока начинается с текущей позиции курсора и продолжается циклически до возврата в исходную точку. Выбирается первый свободный блок, размер которого достаточен для размещения запроса.

#### 3. Разделение блока (Splitting)
Если найденный блок значительно превышает требуемый размер, он разделяется на:
* занятый блок, возвращаемый пользователю
* новый свободный блок, корректно связанный с соседними

#### 4. Обновление курсора
Курсор Next Fit перемещается на следующий блок после выделенного, что определяет стартовую позицию для следующего запроса.

Такой подход обеспечивает предсказуемое поведение аллокатора при большом количестве последовательных операций выделения памяти.

### 3.4 Освобождение памяти

При освобождении памяти блок помечается как свободный.
Если соседние блоки также свободны, выполняется их слияние в один более крупный блок.

Реализована защита от повторного освобождения одного и того же блока (double free). Это позволяет поддерживать целостность структуры памяти даже при некорректных сценариях использования.

### 3.5 Особенности реализации функции Realloc

В рамках данной работы функция `Realloc` реализована в упрощённом виде и не выполняет расширение блока памяти на месте (in-place). При увеличении размера блока производится выделение новой области памяти требуемого размера с последующим копированием данных и освобождением старого блока.

## 4. Тестирование

Для проверки корректности работы менеджера памяти был разработан тестовый сценарий в файле MySimpleEcoOS.c.
Тесты ориентированы на проверку ожидаемого поведения алгоритма Next Fit и не зависят от внутренней реализации компонента, что позволяет объективно оценить корректность работы алгоритма.

В ходе тестирования были реализованы следующие проверки:

#### 1. Тест алгоритма Next Fit
Проверяется, что поиск свободного блока начинается с позиции курсора, а не с начала памяти.

#### 2. Тест слияния блоков (Coalescing)
Подтверждает корректное объединение смежных свободных блоков при освобождении.

#### 3. Тест устойчивости к фрагментации
Проверяет корректную работу аллокатора в условиях фрагментированной памяти.

#### 4. Тест функции Realloc
Демонстрирует корректность перераспределения блока с увеличением и уменьшением размера с сохранением данных.

#### 5. Тест стабильности курсора Next Fit
Подтверждает, что после освобождения блоков поиск следующего свободного блока не начинается с начала памяти.

#### 6. Тест защиты от double free
Проверяет устойчивость аллокатора к ошибочному повторному освобождению памяти.

<img width="655" height="430" alt="image" src="https://github.com/user-attachments/assets/a149efb9-01a9-4c95-9515-344d85f24191" />

Все тесты завершились успешно, что подтверждает соответствие фактического поведения аллокатора ожидаемой логике алгоритма Next Fit.

## 5. Вывод

В ходе лабораторной работы был реализован компонент для работы с памятью с поддержкой алгоритма Next Fit.
Аллокатор корректно обрабатывает динамическое выделение и освобождение памяти, поддерживает автоматическое слияние блоков и устойчив к типовым ошибкам использования. Была реализована и протестирована стратегия Next Fit с сохранением позиции поиска между запросами, обеспечена поддержка динамического разделения и объединения блоков памяти,
реализована защита от double free, а также протестирована корректная работа в условиях сильной фрагментации.

Реализация выполнена в bare-metal окружении без использования стандартных библиотек, с применением только интерфейсов Eco.Framework. Это обеспечивает независимость компонента от операционной системы и подтверждает корректную интеграцию менеджера памяти в экосистему Eco OS.
